namespace rgb_lib {
  Keys generate_keys(BitcoinNetwork bitcoin_network);

  [Throws=RgbLibError]
  Keys restore_keys(BitcoinNetwork bitcoin_network, string mnemonic);

  [Throws=RgbLibError]
  void restore_backup(string backup_path, string password, string data_dir);
};

[Error]
interface RgbLibError {
  AllocationsAlreadyAvailable();
  AssetIfaceMismatch();
  AssetNotFound(string asset_id);
  BatchTransferNotFound(i32 idx);
  BitcoinNetworkMismatch();
  CannotChangeOnline();
  CannotDeleteBatchTransfer();
  CannotEstimateFees();
  CannotFailBatchTransfer();
  EmptyFile(string file_path);
  FailedBdkSync(string details);
  FailedBroadcast(string details);
  FailedIssuance(string details);
  FileAlreadyExists(string path);
  IO(string details);
  Inconsistency(string details);
  Indexer(string details);
  InexistentDataDir();
  InsufficientAllocationSlots();
  InsufficientBitcoins(u64 needed, u64 available);
  InsufficientSpendableAssets(string asset_id);
  InsufficientTotalAssets(string asset_id);
  Internal(string details);
  InvalidAddress(string details);
  InvalidAmountZero();
  InvalidAssetID(string asset_id);
  InvalidAttachments(string details);
  InvalidBitcoinKeys();
  InvalidBitcoinNetwork(string network);
  InvalidColoringInfo(string details);
  InvalidConsignment();
  InvalidDetails(string details);
  InvalidElectrum(string details);
  InvalidEstimationBlocks();
  InvalidFeeRate(string details);
  InvalidFilePath(string file_path);
  InvalidIndexer(string details);
  InvalidInvoice(string details);
  InvalidMnemonic(string details);
  InvalidName(string details);
  InvalidPrecision(string details);
  InvalidProxyProtocol(string version);
  InvalidPsbt(string details);
  InvalidPubkey(string details);
  InvalidRecipientData(string details);
  InvalidRecipientID();
  InvalidRecipientNetwork();
  InvalidTicker(string details);
  InvalidTransportEndpoint(string details);
  InvalidTransportEndpoints(string details);
  InvalidTxid();
  InvalidVanillaKeychain();
  MaxFeeExceeded(string txid);
  MinFeeNotMet(string txid);
  Network(string details);
  NoConsignment();
  NoIssuanceAmounts();
  NoValidTransportEndpoint();
  Offline();
  OnlineNeeded();
  OutputBelowDustLimit();
  Proxy(string details);
  RecipientIDAlreadyUsed();
  RecipientIDDuplicated();
  SyncNeeded();
  TooHighIssuanceAmounts();
  UnknownRgbInterface(string interface);
  UnknownRgbSchema(string schema_id);
  UnsupportedBackupVersion(string version);
  UnsupportedLayer1(string layer_1);
  UnsupportedTransportType();
  WalletDirAlreadyExists(string path);
  WatchOnly();
  WrongPassword();
};

enum AssetIface {
  "RGB20",
  "RGB21",
  "RGB25",
};

enum AssetSchema {
  "Nia",
  "Uda",
  "Cfa",
};

dictionary Media {
  string file_path;
  string digest;
  string mime;
};

dictionary AssetNIA {
  string asset_id;
  AssetIface asset_iface;
  string ticker;
  string name;
  string? details;
  u8 precision;
  u64 issued_supply;
  i64 timestamp;
  i64 added_at;
  Balance balance;
  Media? media;
};

dictionary TokenLight {
    u32 index;
    string? ticker;
    string? name;
    string? details;
    boolean embedded_media;
    Media? media;
    record<u8, Media> attachments;
    boolean reserves;
};

dictionary AssetUDA {
  string asset_id;
  AssetIface asset_iface;
  string ticker;
  string name;
  string? details;
  u8 precision;
  u64 issued_supply;
  i64 timestamp;
  i64 added_at;
  Balance balance;
  TokenLight? token;
};

dictionary AssetCFA {
  string asset_id;
  AssetIface asset_iface;
  string name;
  string? details;
  u8 precision;
  u64 issued_supply;
  i64 timestamp;
  i64 added_at;
  Balance balance;
  Media? media;
};

dictionary Assets {
  sequence<AssetNIA>? nia;
  sequence<AssetUDA>? uda;
  sequence<AssetCFA>? cfa;
};

dictionary Balance {
  u64 settled;
  u64 future;
  u64 spendable;
};

dictionary BtcBalance {
  Balance vanilla;
  Balance colored;
};

enum BitcoinNetwork {
  "Mainnet",
  "Testnet",
  "Signet",
  "Regtest",
};

dictionary ReceiveData {
  string invoice;
  string recipient_id;
  i64? expiration_timestamp;
  i32 batch_transfer_idx;
};

interface RecipientInfo {
  [Throws=RgbLibError]
  constructor(string recipient_id);

  BitcoinNetwork network();

  RecipientType recipient_type();
};

enum RecipientType {
  "Blind",
  "Witness",
};

interface TransportEndpoint {
  [Throws=RgbLibError]
  constructor(string transport_endpoint);

  TransportType transport_type();
};

enum TransportType {
  "JsonRpc",
};

enum DatabaseType {
  "Sqlite",
};

interface Address {
  [Throws=RgbLibError]
  constructor(string address_string, BitcoinNetwork bitcoin_network);
};

interface Invoice {
  [Throws=RgbLibError]
  constructor(string invoice_string);

  [Name=from_invoice_data, Throws=RgbLibError]
  constructor(InvoiceData invoice_data);

  InvoiceData invoice_data();

  string invoice_string();
};

dictionary InvoiceData {
  string recipient_id;
  AssetIface? asset_iface;
  string? asset_id;
  u64? amount;
  BitcoinNetwork network;
  i64? expiration_timestamp;
  sequence<string> transport_endpoints;
};

dictionary Keys {
  string mnemonic;
  string xpub;
  string account_xpub;
  string account_xpub_fingerprint;
};

dictionary EmbeddedMedia {
    string mime;
    sequence<u8> data;
};

dictionary ProofOfReserves {
    Outpoint utxo;
    sequence<u8> proof;
};

dictionary Token {
    u32 index;
    string? ticker;
    string? name;
    string? details;
    EmbeddedMedia? embedded_media;
    Media? media;
    record<u8, Media> attachments;
    ProofOfReserves? reserves;
};

dictionary Metadata {
  AssetIface asset_iface;
  AssetSchema asset_schema;
  u64 issued_supply;
  i64 timestamp;
  string name;
  u8 precision;
  string? ticker;
  string? details;
  Token? token;
};

dictionary Online {
  u64 id;
  string indexer_url;
};

dictionary Outpoint {
  string txid;
  u32 vout;
};

dictionary WitnessData {
  u64 amount_sat;
  u64? blinding;
};

dictionary SendResult {
  string txid;
  i32 batch_transfer_idx;
};

dictionary Recipient {
  string recipient_id;
  WitnessData? witness_data;
  u64 amount;
  sequence<string> transport_endpoints;
};

dictionary RefreshFilter {
  RefreshTransferStatus status;
  boolean incoming;
};

dictionary RefreshedTransfer {
  TransferStatus? updated_status;
  RgbLibError? failure;
};

enum RefreshTransferStatus {
  "WaitingCounterparty",
  "WaitingConfirmations",
};

dictionary RgbAllocation {
  string? asset_id;
  u64 amount;
  boolean settled;
};

dictionary TransferTransportEndpoint {
  string endpoint;
  TransportType transport_type;
  boolean used;
};

enum TransferKind {
  "Issuance",
  "ReceiveBlind",
  "ReceiveWitness",
  "Send",
};

enum TransferStatus {
  "WaitingCounterparty",
  "WaitingConfirmations",
  "Settled",
  "Failed",
};

dictionary Transaction {
    TransactionType transaction_type;
    string txid;
    u64 received;
    u64 sent;
    u64 fee;
    BlockTime? confirmation_time;
};

enum TransactionType {
  "RgbSend",
  "Drain",
  "CreateUtxos",
  "User",
};

dictionary BlockTime {
  u32 height;
  u64 timestamp;
};

dictionary Transfer {
  i32 idx;
  i32 batch_transfer_idx;
  i64 created_at;
  i64 updated_at;
  TransferStatus status;
  u64 amount;
  TransferKind kind;
  string? txid;
  string? recipient_id;
  Outpoint? receive_utxo;
  Outpoint? change_utxo;
  i64? expiration;
  sequence<TransferTransportEndpoint> transport_endpoints;
};

dictionary Unspent {
  Utxo utxo;
  sequence<RgbAllocation> rgb_allocations;
};

dictionary Utxo {
  Outpoint outpoint;
  u64 btc_amount;
  boolean colorable;
  boolean exists;
};

dictionary WalletData {
  string data_dir;
  BitcoinNetwork bitcoin_network;
  DatabaseType database_type;
  u32 max_allocations_per_utxo;
  string pubkey;
  string? mnemonic;
  u8? vanilla_keychain;
};

interface Wallet {
  [Throws=RgbLibError]
  constructor(WalletData wallet_data);

  WalletData get_wallet_data();

  string get_wallet_dir();

  string get_media_dir();

  [Throws=RgbLibError]
  void backup(string backup_path, string password);

  [Throws=RgbLibError]
  boolean backup_info();

  [Throws=RgbLibError]
  ReceiveData blind_receive(
    string? asset_id, u64? amount, u32? duration_seconds,
    sequence<string> transport_endpoints, u8 min_confirmations);

  [Throws=RgbLibError]
  ReceiveData witness_receive(
    string? asset_id, u64? amount, u32? duration_seconds,
    sequence<string> transport_endpoints, u8 min_confirmations);

  [Throws=RgbLibError]
  string sign_psbt(string unsigned_psbt);

  [Throws=RgbLibError]
  u8 create_utxos(
    Online online, boolean up_to, u8? num, u32? size, u64 fee_rate,
    boolean skip_sync);

  [Throws=RgbLibError]
  string create_utxos_begin(
    Online online, boolean up_to, u8? num, u32? size, u64 fee_rate,
    boolean skip_sync);

  [Throws=RgbLibError]
  u8 create_utxos_end(Online online, string signed_psbt, boolean skip_sync);

  [Throws=RgbLibError]
  boolean delete_transfers(i32? batch_transfer_idx, boolean no_asset_only);

  [Throws=RgbLibError]
  string drain_to(
    Online online, string address, boolean destroy_assets, u64 fee_rate);

  [Throws=RgbLibError]
  string drain_to_begin(
    Online online, string address, boolean destroy_assets, u64 fee_rate);

  [Throws=RgbLibError]
  string drain_to_end(Online online, string signed_psbt);

  [Throws=RgbLibError]
  boolean fail_transfers(
    Online online, i32? batch_transfer_idx, boolean no_asset_only,
    boolean skip_sync);

  [Throws=RgbLibError]
  string get_address();

  [Throws=RgbLibError]
  Balance get_asset_balance(string asset_id);

  [Throws=RgbLibError]
  BtcBalance get_btc_balance(Online? online, boolean skip_sync);

  [Throws=RgbLibError]
  Metadata get_asset_metadata(string asset_id);

  [Throws=RgbLibError]
  f64 get_fee_estimation(Online online, u16 blocks);

  [Throws=RgbLibError]
  Online go_online(boolean skip_consistency_check, string indexer_url);

  [Throws=RgbLibError]
  AssetNIA issue_asset_nia(
    Online online, string ticker, string name, u8 precision,
    sequence<u64> amounts);

  [Throws=RgbLibError]
  AssetUDA issue_asset_uda(
    Online online, string ticker, string name, string? details, u8 precision,
    string? media_file_path, sequence<string> attachments_file_paths);

  [Throws=RgbLibError]
  AssetCFA issue_asset_cfa(
    Online online, string name, string? details, u8 precision,
    sequence<u64> amounts, string? file_path);

  [Throws=RgbLibError]
  Assets list_assets(sequence<AssetSchema> filter_asset_schemas);

  [Throws=RgbLibError]
  sequence<Transaction> list_transactions(Online? online, boolean skip_sync);

  [Throws=RgbLibError]
  sequence<Transfer> list_transfers(string? asset_id);

  [Throws=RgbLibError]
  sequence<Unspent> list_unspents(
    Online? online, boolean settled_only, boolean skip_sync);

  [Throws=RgbLibError]
  record<i32, RefreshedTransfer> refresh(
    Online online, string? asset_id, sequence<RefreshFilter> filter,
    boolean skip_sync);

  [Throws=RgbLibError]
  SendResult send(
    Online online, record<DOMString, sequence<Recipient>> recipient_map,
    boolean donation, u64 fee_rate, u8 min_confirmations, boolean skip_sync);

  [Throws=RgbLibError]
  string send_begin(
    Online online, record<DOMString, sequence<Recipient>> recipient_map,
    boolean donation, u64 fee_rate, u8 min_confirmations);

  [Throws=RgbLibError]
  SendResult send_end(Online online, string signed_psbt, boolean skip_sync);

  [Throws=RgbLibError]
  string send_btc(
    Online online, string address, u64 amount, u64 fee_rate, boolean skip_sync);

  [Throws=RgbLibError]
  string send_btc_begin(
    Online online, string address, u64 amount, u64 fee_rate, boolean skip_sync);

  [Throws=RgbLibError]
  string send_btc_end(Online online, string signed_psbt, boolean skip_sync);

  [Throws=RgbLibError]
  void sync(Online online);
};
